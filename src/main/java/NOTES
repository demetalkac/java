INTERVIEW
-package day03_scanner;- IfStatement02 = Example 1: Type code to print "Weekday" for the weekday names, "weekend day" for the weekend days
                                                Monday - Friday ==> Weekday       Saturday, sunday ==> Weekend day

-package day05ternarystringmainpulation; ->public class NestedTernary01 { "leap year"

-  package day08stringmanipulationloops; -> public class StringManipulations01 { "Example 2: Swap the integers"





*       How do we get the data from the user?
       -1.Adım: Scanner classından object olustur
       -2. Adım: Kullanıcıya ne yapacagını söyle
       -3.Adım: Kullanıcıdan alınan datayı bir variable’ın icine koyun

       1.Step: Create an "object" from "Scanner Class".

       Class Name     Object Name    Assignment Operator    new Keyword     Constructor==>Class Name +()
        Scanner        input             =                    new               Scanner(System.in);
                       scan



1-)         Wrapper classes are "Non-Primitive data types.(Primitive data typeları non-primitive'e cevirir)

            Primitive      Wrapper Class
            byte             Byte
            short           Short
            int            Integer
            long            Long
            float          Float
            double        Double
            boolean       Boolean
            char          Character

            int i= 12; //there is no method, just value
            Integer k= 12; //there are many methods in the coding

            char c= 'A';
            Character d= 'A';

* Autoboxing: To convert "primitive data" to "wrapper class" data type.

            byte b= 23; //close to add any actions/methods
            Byte wb= b;  //is open to addition of the methods

* Unboxing: To convert "wrapper class" to its "primitive data"

            Short ws= 34; //open to be added the methods
            short s= ws;   //container is closed to add methods

* How to get the minimum and maximum values of numeric types in java

            System.out.println(Integer.MAX_VALUE); //

2-)  SWİTCH
   Note: "break" keyword is used in "switch" statement to stop next case executions.
         "break" keyword takes us to the outside the switch statement

  note: Inside the switch parenthesis, you can use just, "int", "byte", short ,char String data types
  note: boolean, long, float, double cannot be used in switch statement


3)            TERNARY
  "ternary" does the same with "if else" by using more simple syntax

  ÖRNEK:If an integer is positive print "The integer is positive" otherwise print "The integer is not positive"
         int i = 12;
          Condition     ?       Will be selected for true condition      :    Will be selected for false condition
          String result = i>0         ?           "The integer is positive"            :        "The integer is not positive";
          System.out.println(result);

NOT: Ternary farklı data tiplerinde sonuc return ederse sonucun data tip,ini "Object" yapınız.
  örn:  int a = 12, b = -10;
        Object res = a>0 && b>0 ? a*b : "I do not how to multiply";
        System.out.println(res);

 NestedTernary: int year= 1600;
                String isLeap = year%100==0 ? (year%400==0 ? "Leap" : "Not leap") : (year%4==0 ? "Leap" : "Not leap"  );
                System.out.println(isLeap);


4-)  SEMBOLLER

*    Note:  % (modulus operator) ==> gives the remainder of a division operation.
              " % " is called "modulus"  operator

*     Note: "!" in java means "not"
             !true ==> false   !false ==> true  !!true ==>true
               "!=" means "does not equal to"

*    Note: In java "==" means equals.
      Note:  in java "=" is assignment operator.
      Note: To compare Strings use "equals()" , do not use "==



*      "||" this sign means "OR" operator in Java.
      equalsIgnoreCase()==>java does not care about the upper or lower case

             Note: " OR" operator in java ==> ||
                    "||" can be used just with booleans

              To get false from  "||" operator everything should be false.
              just a single "true" makes the result true.==>|| is optimistic
              To get "false" from || every condition should be false
              true || true ==> true
              true || false ==> true
              false || true ==> true
              false || false ==> false

*         && (and) islemi sadece "boolean" ile kullanılır.
             && (and) islemi mükemmelliyetcidir, true sonucunu alabilmek icin hersey true olmalıdır.
             Bi tane false varsa sonuc false olur.

            true && true ==> true
            true && false ==> false
            false && true ==> false
            false && false ==> false

NOT: "and" ve "or" bir arada kullanınca karısıklık olmaması icin parantez ile kullanmak daha iyidir:
     (e>0 && f>0) || (e<0 && f<0)


5)  MATEMATİKSEL İSLEMLER:

  * absolute(mutlak deger): //For positive numbers and zero absolute value is the same with the number(sayı pozitif ve  sıfır ise mutlak deger kendileridr)
                        //For negative numbers to find absolute value multiply the number by -1 (negatif sayıların mutlak degeri -1 ile carpılmıs halidir)

  * n =Math.abs(n); //abs() methodu negatif sayıyı pozitif sayıya cevirir. Ve "Math" classından cagılır.

  * a rectangle area==> width*length= area

  * diktörtgenin alanı => kısaKenar*uzunKenar

  * diktörtgenin cevresi => 2*kısaKenar + 2*uzunKenar

  * a rectangular prism then calculate the total area:formula=  2*w*l +  2*h*l  +  2*w*h

  * dairenin alanı => 3,14*r*r  veya  (314*r*r/100) seklinde de yazabiliriz.  --- r: yarıcap

  *ücgenin cevre uzunlugu => a+b+c




  *cemberin cevresi => 2*3,24*r veya  2*314*r/100

  * '%': firstNum * secondNum/100

6-)NOT: char variable'ları matematiksel islemlerde kullanırsanız, Java onların ASCII degerlerini kullanır

   not: Java'da "+" sembolunun 2 anlamı var: 1- Toplama islemi    2- Birlestirme islemi(concatenation)

   next() : Kullanıcıdan String olarak girilen datayı(İLK KELİMEYİ) alır.
   nextLine(): Kullanıcıdan String olarak girilen dataları(STRİNGİN TAMAMINI) alır.

   toLowerCase() methodu bir String deki tum karakterleri kücük harfe cevirir.

   length() :Kac tane karakter oldugunu verir

   charAt(0) : ilk karakteri almada kullanırız



7-)     binarySearch() method -Array de kullanıyoruz.
                // binarySearch() methodunu kullanmadan önce mutlaka "Arrays.sort()" methodunu kullanmalıyız.
                // binarySearch() bize bir elementin arrayde olup olmadıgını verir. Eger element arrayde varsa o elementin indexini verir.
                // binarySearch() methodu tekrarlayan elementler icin kullanılmaz( iki tane 22 varsa bazen 1.yi bazen 2. 22'i verir, o nedenle kullanılmaz)
                //      i)If the element exists binarySearch() method returns the index of the element

          //Example 1: Type code to check if a specific element exists in an Array or not
                String str[] = {"Ali", "Tom", "Carl", "Angie"};


                Arrays.sort(str);//["Ali", "Angie", "Carl", "Tom"]

                int idx = Arrays.binarySearch(str, "Carl"); // 2 parametre ile calısır: 1.arrayın adı, 2.aradıgımız element
                System.out.println(idx);//If the index is zero or more, it means the element exists

                int idxMiami = Arrays.binarySearch(str, "Miami");
                System.out.println(idxMiami);   //  -4 ==>  "-" means does not exist. ("-" elementin arrayde olmadıgını, "rakam(4)" ise olsaydı kacıncı sırada oldugunu gösterir. sırayıda sort kullandıgımız icin ona göre sıraya sokar)
    //          "4" means if it exists it would be 4th element



8-) ARRAY NASIL YAZDIRILIR?
              String dateArray[]= date.split("/");
              System.out.println(Arrays.toString(dateArray));


9-) MULTIDIMENSIONAL ARRAY NASIL YAZDIRILIR?
              String brr[][]={ {"Tom","Jim"},{"Angie"},{"Carl", "Christ","Ali"} };

              System.out.println(Arrays.deepToString(brr)); //[[Tom, Jim], [Angie], [Carl, Christ, Ali]]

11-) Array veya Collection varsa "for-each-loop" kullanmak ilk tercihiniz olsun
     Array veya Collection var ama "index" kullanmak zorundasınız o zaman "for-each-loop" calısmaz, "for-loop"  ,
     "while-loop" veya "do-while-loop" kullanmalısınız.


12-) ARRAYLIST
             //When you create an Array, you have to declare the length of the Array.
             //But when you use "Lists" no need to declare the number of elements at the beginning.
             //"Lists" are flexible for length but Arrays are not

             //Lists are for storing multiple data in the same data type
             //Lists store non-primitive data types, Arrays cannot
             //Lists cannot store primitive data types.
             //Lists have many useful methods, Arrays do not

             //Arrays are so fast
             //Arrays uses memory so less
             /*
             ArrayListler aynı data tipine sahip birden fazla data'yı depolamak icin kullanılır.
            INTERWİEV:!!! Array ile ArrayListlerin farkı nedir?
             1- Array olustururken Array'in icine kac tane elemen koymamız gerektigini söylemeliyiz,
             söyledigimiz elemen sayısından fazla eleman koyamayız.
             Arrayler eleman sayısında "fixed"dirler.

             ArrayListler olustururken element sayısını söylemeye gerek yok,cunku ArrayListler element sayısında "flexible"dirler.

             2-Array'lerin icine primitive ve referance'lar konulabilir.
             ArrayListler icine ise sadece "non-primitive"ler konulur, primitive ler ile calısmaz.

             3- Arraylar yapıları basit oldugu icin super fast, cok hızlı. Array'ler memory'i cok az kullanılır.

             4-Arraylerde method daha az. ArrayListlerde method daha fazladır,daha gelismis bir yapısı vardır.

             note: Eleman sayısı kesin belli olan dataları depolamak icin Array kullanılır,
                   ama eleman sayısı degisken olan coklu datalar icin Array kullanma riskini almayın.ArrayList kullanın.
              */


13-)            **How to create a List(Arraylist)**
             //1.Way:
             ArrayList<Integer> myList1 = new ArrayList<Integer>();
             //2.Way:
             ArrayList<Integer> myList2 = new ArrayList<>();
             //3.Way:
             List<Integer> myList3 = new ArrayList<>();

             **How to print a list on the console**
              System.out.println(myList3);// []

14-) NOTE:iki arrayList'in esit olabilmesi icin ilk önce eleman sayılarını esit olup olmadıgını kontrol etmeliyz,
          elemanlar esit olmalı ve aynı elemenlar aynı index'te olmalı
          örnegin "m" ve "n" adında iki list'imiz var ;

                      if (m.size()!=n.size()){
                          System.out.println("The lists are not same");
                          break;

                      }



  15-)     "PassByValue"  ==> day17listpassbyvalue pacgate'nin icinde

               1) When you use a variable inside a method, Java creates the copy of the variable
                  and uses it inside the method. Java does that to protect the original value of the variables.
                  If in every method usage, the value changes, it creates very big problems.
                  --
                  1) Bir method içinde bir variable kullandığınızda, Java değişkenin(variable) kopyasını oluşturur ve onu
                   method'un içinde kullanır. Java, variable'ın orijinal değerini korumak için bunu yapar. Buna "Pass by value-Değere göre geçiş" denir
                   Her metot kullanımında değer değişirse çok büyük sorunlar yaratır.

              2) Some programming languages do not use "Pass by value" they use "Pass by reference".
                 If you use "Pass by reference" original will change in every method usage.
                 --
                 2) Bazı programlama dilleri orjinal degeri koruma altına almamıstır, Bu isi developer'lara bırakmıstır.
                     Yani bazı programlama dilleri "Pass by value" kullanmaz, "Pass by reference" kullanırlar.
                     "Referansa göre geçir" kullanırsanız, orijinal her yöntem kullanımında değişecektir.

             3) If you insist on changing the original value in Java you can do it as well.
                Assign the updated value to the original variable then original value will be updated.
                --
                3) Java'daki orijinal değeri değiştirmekte ısrar ediyorsanız, bunu da yapabilirsiniz.
                          Güncellenen değeri orijinal değişkene atayın, ardından orijinal değer güncellenecektir.


 16-)   "Post Decrement-Increment"  and  "Pre Decrement-Increment"

             int a = 12;
             int b = a++; //Post Increment => variable'ı aldıktan sonra artırma yapar
             System.out.println(b); //12 => java önce "a"ı gördi ve aldı "b"nın icine koydu sonrada ++ isaretini gördü ve "a"ı alıp 1 artırdı.
             System.out.println(a); //13

             int x=15;
             int y=x--; //Post Decrement
             System.out.println(x); //14
             System.out.println(y);//15

             int m = 21;
             int n= ++m; // Pre Icrement => java önce "m"i artırdı sonra "n"nin icine koydu.
             System.out.println(m); //22
             System.out.println(n); //22

             int t = 32;
             int u = --t; //Pre Decrement
             System.out.println(t); //31
             System.out.println(u); //31

  17-)    "Varargs"
              1)If you want to make number of parameters flexible in a method, use "varargs"
              2)To create a varargs "Data Type + ... + space + a name for the varargs"
              3)"Varargs" use Arrays behind. When you work with varargs you may think you are working with Arrays.
              4)"Varargs" can accept zero or more elements
            ınt q1==> 5)Can I use another regular parameter after "varargs"?
                No, because "varargs" cannot be made full, second parameter will be unreachable, it will give error.
                "varargs" must be last parameter everytime.

             ınt q2==> 6)Can I use another regular parameter before "varargs"?
                Yes, you can use many regular parameters before "varargs"

            intq3==> 7)Can I use multiple "varargs" parameter in a method?
                   No.Because once we type varargs as first parameter then we cannot add other parameters after varargs...

             "varargs" : variable argument

          public static void main(String[] args) {

              System.out.println(add(3,5)); //8
              System.out.println(add(3,5,2)); //10
              System.out.println(add()); //0
              System.out.println(add(3)); //3
          }

          // Create a method adds two integers ( sade ce 2 tane sayı degil, istedigim kadar sayıyı toplayabilirim.
          public static int add(int... a){

              int sum =0;

              for (int w : a){  //varags'ların arkasında arrays calısır, o nedenle for each kullanıyoruz.

                  sum = sum + w;
              }
              return sum;
          }

  18-)      MethodOverlooding

            overlooding = asırı yükleme

            Bir method aynı isim ile farklı parametrelere sahip birden fazla method olusturmaktır.
             Method Overlooding nasıl yapılır?

             1-Method isimleri aynı olmalıdır
             2- Method parametreleri aynı olmalıdır
                i- Parametre sayıları degistirilebilir
                ii- Parametrelerin data tiplerini degistirilebilir
                iii-Parametrelerin yerlerini degistirilebilir ancak data tipleri farklı ise.
             3-Method ismi+ Parametreler = Method Signnature
             not:Method Signnature dısında ne degistirirseniz degistirin Java o methodları farklı kabul etmez.
       ----
               1)If you create a method with the same name and different parameters, it means you are doing "Method Overloading"
               2)"Method Overloading" happens in a single class, therefore we do not need "inheritance" for "Method Overloading"
               3)To do "Method Overloading"
                   i)Do not change the method name
                   ii)Change the parameters by changing the a)number of the parameters  b)data type of the parameters
                    c)places of the parameters

                   Note: To use option "c" data types must be different
               4)"private" methods can be "overloaded"
               5)"final" methods can be "overloaded"
               6)"static" methods can be "overloaded"
               7)Why do we need "Method Overloading"?


            public static void main(String[] args) {

                add(3,5);
                add(3, 5.0);

            }

            public static void add(int a, int b){
                System.out.println(a+b);
            }

            public static void add(int a, int b, int c){
                System.out.println(a);
            }

            public static void add(double a, int b){
                System.out.println(a+b);
            }

            public static void add(int a, double b){
                System.out.println(a);
            }
        }

            /*
                1)If you create a method with the same name and different parameters, it means you are doing "Method Overloading"
                2)"Method Overloading" happens in a single class, therefore we do not need "inheritance" for "Method Overloading"
                3)To do "Method Overloading"
                    i)Do not change the method name
                    ii)Change the parameters by changing the a)number of the parameters  b)data type of the parameters
                     c)places of the parameters

                    Note: To use option "c" data types must be different
                4)"private" methods can be "overloaded"
                5)"final" methods can be "overloaded"
                6)"static" methods can be "overloaded"
                7)Why do we need "Method Overloading"?

                Note: Method Overloading + Method Overriding = Polymorphism
             */


   19-)  StringBuilder "day19stringbuilder"ın icinde
               //What is "StringBuilder Class"?
                //"StringBuilder Class" is for creating "Mutable Strings"

                //We use "String Class" to create a String, why or when we will need "StringBuilder Class"?
                //String Class is "Immutable", "StringBuilder Class" is "Mutable".

                // "Immutable" : degismeyen,, duragan
                // "Mutable" : degisime acık

             //How to create a StringBuilder Object
             //1.Way:
             StringBuilder sb1 = new StringBuilder("Mary");
             System.out.println(sb1);//Mary

             sb1.append("Karl");
             System.out.println(sb1);//MaryKarl

             //2.Way:
             StringBuilder sb2 = new StringBuilder();
             System.out.println(sb2);//Empty

             sb2.append("Clara ");
             System.out.println(sb2);//Clara

             sb2.append("Ocean ");
             System.out.println(sb2);//ClaraOcean
not: degerleri append() (concent gibi) methodu ile tek tek ekleyebiliriz VEYA coklu ekleme yapabiliriz:
             ör:sb2.append("Miami ").append("FL ").append("USA");
             System.out.println(sb2); //ClaraOceanMiamiFLUSA

  20-) "Access Modifier" => day20accessmodifiersinheritance packgende "Student class" ve "Runner class"ında
      - Bir classtan baska classa ulasmak istiyorsak obje olusturmalıyız.
      Yani Runner class da Student classa ulasmk istiyorsak obje olusturmalıyız. public,protected ve default olana aynı
      packgede iken ulasabilirim, ama privide de ulasamayız.

      a)What is the difference between "default" and "protected" access modifiers?
          i)"protected" access modifier is wider than "default" modifier
          ii)"default" ones cannot be used from outside the package, therefore it's other name is    "package private"
             "protected" ones can be used form the class in other packages if the classes are "child classes"

      b)Could you please tell the name of the access modifiers from the narrowest to the widest?
           private < default < protected < public

      c)Could you please explain all access modifiers?
NOT: "default"  da “package privide” da denir.

  //It is accessible from entire the project , there is no restriction
   public String stdName = "Tom Hanks";

   // It can be used just inside the"Student" class.
   //It can be used just inside the class it was created
   private String stdId = "TH202217007";


   //It can be used just inside the "day20accessmodifiersinheritance" package
   //It can be used just inside the package it was created
   double stdGpa = 3.83; //If you do not type any access modifier it will be "default"


   //It can be used inside the "day20accessmodifiersinheritance" package, and from the child classes in other packages
   protected String stdAddress = "Miami, FL USA";
     ---
           //I accessed data on the object
          Student std1 = new Student();
          System.out.println(std1.stdName); //Tom Hanks

           Student std2 = new Student();
           System.out.println(std2.stdGpa); //3.83

           // If you want to access data inside the class without using any object, the data must be static
           System.out.println(Student.Address); //Miami, FL USA

  21-)  "" Inheritancepackage" => day20accessmodifiersinheritance İCİNDE class Animal DA.

      inheritance: miras anlamındadır. Childe'ların ihtiyacı olanları(method...) parent class'tan kullanabilmesine denir.
      1- Tekrarlı kod problemi
      2- Cod tamirinin(maintenance) cok zor olması problemi
      3- Cok büyük classlar olusturma problemi , bu 3 problemi cozmek icin inheritance olusturmus java.
         --
     - Inheritance'in calısması icin classlar arasında parent-childe iliskisi kurmalıyız.
     - parent-child iliskisi icin "extends" keyword'unu kullanırız. "extends"in solunda child class,
       sagında parent classın ismi olur. ör: public class Cat extends Animal { => Cat child, Animal parent
     - Child Class object'ler Parent Cass'dan method ve variable'ları kullanabilirler.
     - Parent Class object'ler Child Cass'dan method ve variable'ları kullanamaz.
        ---
            "method ve variable"
     - "privede" method ve variable'lar Child Class'lar tarafından kullanılamazlar(yani prived olanlar inheritance edilemez)
     -"protected" method ve variable'lar Child Class'lar tarafından kullanılabilirler(yani protected olanlar inheritance edilebilirler)
     -"public" method ve variable'lar Child Class'lar tarafından kullanılabilirler(yani public olanlar inheritance edilebilirler)
    -"default" method ve variable'lar aynı package'deki Child Class'lar tarafından kullanılabilirler(yani default olanlar inheritance edilebilirler)


    NOT: "Object class" bütün kılasların parenti oldugu icin onda yeralan bütün methodları extends yapmadan da kullanabiliriz.
         Java da "Object class" haric her classın parent'ı vardır.

         ---
         inheritance Cesitleri:
         1- Multilevel Inheritance =>her classın bir parentı ve her classın bir childı var.apartman gibi, java kabuleder
         2- Hierarchical Inheritance => Bir parentın birden fazla child'ı var
         3- Multible Inheritance => bir childen iki parenti var. java doesnt support(desteklemez)
         4- Single Inheritance => bir child class icin bir Prent Class demektir, java bunu destekler.

         ----
                "objekt" olusturup variable cagırma:
           objekt olustururken: (aralarında parent-child iliskisi var yani extends edilmis classlar icin konusuyoruz):
        - bulundugu classın ismi ile olusturabiliriz => Cat cat1 = new Cat();
        - bulundugu classın parentinin ismini kullanarak da olusturabiliriz  =>Mamal cat2 = new Cat();
        - bulundugu classın parentinin parentinin ismini kullanarak da olusturabiliriz =>Animal cat3 = new Cat();
          Yani objeckt olustururken data type'nı bulundugu clastan secebilecegimiz gibi parentlarından da secebiliriz.Bunu
          yapacagımız göre seceriz.
       * Classların icine aynı isimle variable koydugumuzda: Kullanmak istedigimizde, variable'ı objekt icinde cagırdıgımızda ,
       hangi data type ile objeckt olusturduysak onun icindeki variable degerini getirir bize. ör:
        Mamal clasında ,"public int a = 14;" olusturduk ve Cat classında da "public int a = 10;" olusturduk
        Eger Cat objesinden cagırırsam: Cat cat1 = new Cat();
                                        System.out.println(cat1.a); ==> 10
        Ama Mamal objesinden cagırırsam: Mamal cat2 = new Cat();
                                        System.out.println(cat2.a); ==> 14 ,olur.

     not:  Mamal clasında ,"public int b = 74;" olusturduk ama Cat classında b variable yok ise, ve
           Cat classından obje yapıp ordan cagırsak variable'ı  Cat classında olmadıgı icin parent'ı
           olan Mamal classına gider ordan alır.
          -Inheritance da variable'lar seclirken Java object'in data type'ına bakar.
           Oncelikle istedigimiz variable'ı Objectin data type'ı olan Class'da arar.
           Ama variable O child classda yoksa parent'ına gidecek ordan alacak.
           Hicbir parent classda bulamazsa hata verir.

        ----------
                              "methodlar"
  *Objeckt olustururken Object'in data type'i Child Class'lardan secilemez.:
   Cat cat5= new Mammal(); seklinde olamaz, error verir.
   Mammal cat5= new Mammal(); seklinde olmalı

   *Inheritance'da metdod'lar secilirken Java Constructor'a bakar.
    Önce istedigimiz method'u Constructorı kullanılan class'dan alır.
      Cat cat4= new Cat();
      cat4.eat(); =>Cat Classındaki eat methodunu alır,cunkü constructorı da Cat()

     Mammal cat5= new Mammal(); =>Mammal Classındaki eat methodunu alır,cunkü constructorı da Mammal()

   *Mammal Classına drink() methodu koyup:
                     "public void drink(){
                     System. out.printl.("mammal eat"); } ve Cat methodu ile cagırsak constructorına bakar
                                                    Cat clasında drink methodu olmadıgı icin parantı olan Mammal'dan alır.
        Cat cat4= new Cat();
        cat4.drink(); //  "mammal eat" , seklinde gelir.

   -Yani method cagırırken constructora bakar ve Constructorı olan clasta yoksa bir üst parentendan alır, parentlarında da yoksa hata verir.

       -----
          "Constructor"
     *"Constructor" lar obje üretmede kullanılır, constructor olmadan obje üretilemez.
     *Constructor da :-return typ yok
                      - class ismi ile aynı olmalı ismi
                    - ismi büyük harfle baslamalı
       Methodlarda ise  :-return typ var
                         - class ismi ile aynı olmak zorunda degil istedigimiz ismi verebiliriz
                        - ismi kücük harfle baslamalı

     * access modifier => constructor ismi(clas ismi ile aynı olmalı) => () => {}
          public Mammal(){ System. out.printl.("mammal"); }
     *Constructor'un nasıl callıstıgına bakmak icin runnur classta main icinde bir obje olusturup calıstırırsak,
     ilk önce parenttaki constructor'ı görürüm sonra en alttaki child classın constructorını görürüm.
      ör: Animal=> Mammal => Cat class'larımız var ve bu classlarda constructorları var
          Cat cat1 = new Cat(); => calıstırdıgımızda sırasıyla  "Animal=> Mammal => Cat" constructurlarını görürüz konsolda.
    Yani constructorlar yukardan asagıya dogru calısır.

     * -Java da object olustururken constructorlar parenttan child’a dogru calıstırır
       -Java en üst parent constructor’a cıkabilmek icin “super()” kodunu kullanır.
       -“super()” kodu her constructor’ın ilk satırında “gizli” olarak bulunur.
       -“super()” kodunu istersek görünür sekilde yazabiliriz
       -“super()” kodunu görünür sekilde yazarsak , ilk satır dısında bir satıra koyamayız, hata verir.
       -“super()” kodu parent class’tan constructor cagırmaya yarar.
                      -----------
                //1) super() is used to call constructor from parent class.
                //2) super() is in the first line of every constructor body.
                //3) super() is invisible as default, if you want you can type it explicitly.

                 Civic d = new Civic(2021);
                 //1) super() can be used with parameters like super(true), super("Hybrid"), super(2021)
                  //2) When a class has multiple constructors to select the constructor we need, we use
                   //   super() with parameters

       **
       1-Class olusturuldugunda  Java otomatik olarak görünmez bir constructor verir, cünkü Java Class'ın bir kalıp oldugunu
        ve Object olusturmak icin olusturuldugunu ve Object olusturmak icin constructor'ın sart oldugunu bilir.
       2-Java'nın otomatik olarak olusturuldugu bu görünmez constructor'a "default constructor" denir.
       3- Biz kendimiz herhangi bir constructor olusturdugumuzda Java  "default constructor"ı siler.
       4- Bir classta birden fazla constructor olabilir. Ama parametreleri farklı olmalı
       ör: public Honda(){}
           public Honda(int price)}
           public Honda (int price, int year)} ... gibi

       5-"this" keyword "bu class" anlamındadır.örnegin "this.price" demek bu class'daki "price" isimli variable demektir
       "this.price" syntax'i construclorın icinde kullanılır.

       6- Constuctor kullanarak variable'lar üzerinde yaptıgınız degisimler sadece Object üzerindeki variable'ların degerlerini degistirir.
       Class daki variable degerlerini degistirmez.

       /*
                   1)When you try to access a "variable" by using an object in inheritance,
                   start to look for the "variable" in the class used in the "data type of the object"

                   2)When you try to access a "method" by using an object in inheritance,
                   start to look for the "object" in the class whose "constructor" was used

                   3)In te first line of every constructor there is invisible "super()" to call default constructor from
                   the parent class, if you want you type it explicitly.

                   4)Data type of object can be selected from the class itself or from the parents of the class.
                     Object dog = new Dog();   OR   Animal dog = new Dog();   OR   Mammal dog = new Dog();
                      OR   Dog dog = new Dog();

                   5)"private" class members cannot be inherited
                     "default" class members can be inherited if the child class in the same package with the parent class.
                     "protected" and "public" class members do not have restriction in inheritance
               */

                          /*
                           1)this() is used to call constructor from the same class.
                           2)this() must be in the first line in a constructor body.
                           3)this() is used to call constructor from the same class, super() is used to call constructor from parent class.
                       */


  22-)           METHOD OVERRIDING
            1)When the child classes use the methods from the parent classes, we may need to update implementation of the methods.
              For example; in Animal class eat() method tells "Animals eat", but to tell "Animals eat" in Cat class is not good.
              To be able to create specific implementation for the Cat class like "Cats eat" we should update the method body.
              This is called "Method Overriding"
            2)To do "Method Overriding" we need "inheritance". If there is no "inheritance" it means there is no "Method Overriding".
            3)When we use "Method Overriding", we do not touch to the "Method Signature"(Method Name + Parameters)
            4)"@Override" annotation checks the "Overriding Rules" when you do "Overriding"
            5)When you do "Method Overriding", you cannot use "Narrower" access modifiers in child class,
              you can use same or wider access modifiers.
            6)When you do "Method Overriding", the method in parent class is called "Overridden Method",
              the method in child class is called "Overriding Method"
            7)When you do "Method Overriding", if the return type is "void" in "Overridden Method",
              return type of the "Overriding Method" must be "void"
            8)When you do "Method Overriding", return type of the "Overriding Method" can be same or the child
              of the return type of the "Overridden Method"
              From child return type to parent type you must have "IS-A" Relationship
            9)Between the Wrapper Classes, Java did not create "Parent-Child Relationship", therefore
              between the Wrapper Classes there is no "IS-A" relationship. If there is no "IS-A" Relationship
              you cannot change the return types in "Method Overriding"
            10)When you do "Method Overriding", if the return type of the "Overridden Method" is "primitive"
              you cannot change it in "Method Overriding" because "primitive" data types are not classes
              if they are not classes you cannot have "IS-A" relationship.

              Note: If a method is final, it means its body cannot be updated.

            11)Body of a "final method" cannot be updated, because in Overriding we change the method
              body, but final methods do not allow us to change the body

            12)"private" methods cannot be overridden, because to override a method we have to access
              to it. "private" methods are not accessible from other classes

            13)"static" methods cannot be overridden because "static" things are common for
              all child classes, if any child class updates the static method body other child classes
              will be effected as well, therefore Java does not let you override a static method.


   23-)        "super"  ve "super()" ın FARKLARI
                    1)"super" keyword is used to get data(variables + methods) from parent classes in inheritance
                    2)If there is no data(variables + methods) in parent Java looks for the data in grandparents
                      If no parent has the data(variables + methods) Java gives Compile Time Error
                    3)"super()" must be the first statement in the constructor body, but "super" can be in any line
                    4)"super()" is for calling "constructors" from parent class, "super" is for calling variables and methods
                      from the parent class
                    5)"this" is used to call data(variables + methods) from the class itself.
                      When you use "this", it means you are telling to Java "do not go to the parent, stay in this class"
                 */

   24-)    /*
                                 POLYMOPHISM
                @Override : @Override annotation'inı kullanarak, java'nın yaptıgımız Override islemini kontrol etmesini saglarız.

                1- Override yaparken "method'un body"si degistirilir( cünkü methodun isleyisini-imlementation- begenmedigimiz iccin degistiririz)
                2- Override yaparken asla method signature (isim ve parametre) degistirilemez.
                3-Override yaparken "inheritance" olmak zorundadır.( cünkü parent-chid iliskisi olmadan yapamayız)
                4-Override yaparken "access modifier"lar belli kurallara göre farklılastırılabilirler.
                 i- "privede" methodlar override edilemezler
                 ii-Child class daki "override edilen" method'un access modifier'i Parent class'daki
                    method'un access modifier'i aynı veya daha genis olmalıdır.
                    note: Child class daki method'un access modfier'i daha dar olamaz.
                 iii- "default method"lar aynı package icindeyse override edilebilirler,
                       farklı package'den override edilemezler.
                5-Parent Class'daki methodun "return type"i void ise "retuen type" degistirilemez.
                6-Parent Class'daki methodun "return type"i primitive ise "retuen type" degistirilemez.
                  örnegin; asıl method'ta return type int ise override yaptıgımız methodun return type'ı da int olmalı
                7-Parent Class'daki methodun "return type"i Wrapper ise "retuen type" degistirilemez.
                8-Parent Class'daki methodun "return type"i Parent Class ise "retuen type" child'lardan biri olabilir.
                 note:Child class'daki return type Parent Class'dakinden genis olamaz.
                 note: Aralarında parent-child ilskisi olmayan classlar Overriding'de return type degisiminde kullanılamazlar.
                      Mesela "Short", "Integer"'dan kücüktür, fakat aralarında "parent-child" iliskisi
                      olmadıgından "Integer" yerine "Short" kullanılamaz.
                note: Child'daki methodun return typendan parenttaki methodun return type'na gidiste "IS-A" Relationship olmalı
                      Aralarında "ıs-a" relationship olan data type'lara "covariant" da denir.

               - child'dan parent'a gidiliyorsa "IS-A" iliskisi var. ör: Cat is a Animal
                 Yani child'an parent'e giderken return type da "İS A" iliskisi olmalı."IS A" iliskisi yoksa return type degistirilemez.
               - parentten child'a gidildiginde  ise "HAS A". Animal has a Cat

               **
               Asagıdaki child clasdaki  bu methoda "Overriding Method" (yani override yapılmıs onlamında) denir.
                   @Override
                    public void eat() {
                    System.out.println("Cats eat...");
                   }
                    ----
                    Asagıdaki parent clasdaki bu methoda ise "Overridden Method" denir.
                    public Animal create(){
                      return new Animal();
                    }
               9- "final" methodlar Override edilemezler, cünkü "Overriding" de method body degistirilir
                   fakat "final" method body degistirilmesine musade etmez.
               10- Polymophism = overloading + overriding


              11- overloading ve overriding arasındaki farklar nelerdir?
                  i-Overloading icin "inheritance" gerekmez fakat Overriding icin gerekir.
                  ii-"private" methodlar Overload edilebilir, Override edilemezler
                  iii-"final" methodlar Overload edilebilir, Override edilemezler
                  İV- "Overloading static polymorphism" olara, "Overriding" "dynamic polymorphism" olarak adlandırılır.
                     Cünkü static methodlar Overload edilebilir, override edlemezler.
                  v-  "Overloading" de method signnature degisir ama "Overriding1 method signature a dokunmaz.

             */
                      /*
                        METHOD OVERRIDING
                          1)When the child classes use the methods from the parent classes, we may need to update implementation of the methods.
                            For example; in Animal class eat() method tells "Animals eat", but to tell "Animals eat" in Cat class is not good.
                            To be able to create specific implementation for the Cat class like "Cats eat" we should update the method body.
                            This is called "Method Overriding"
                          2)To do "Method Overriding" we need "inheritance". If there is no "inheritance" it means there is no "Method Overriding".
                          3)When we use "Method Overriding", we do not touch to the "Method Signature"(Method Name + Parameters)
                          4)"@Override" annotation checks the "Overriding Rules" when you do "Overriding"
                          5)When you do "Method Overriding", you cannot use "Narrower" access modifiers in child class,
                            you can use same or wider access modifiers.
                          6)When you do "Method Overriding", the method in parent class is called "Overridden Method",
                            the method in child class is called "Overriding Method"
                          7)When you do "Method Overriding", if the return type is "void" in "Overridden Method",
                            return type of the "Overriding Method" must be "void"
                          8)When you do "Method Overriding", return type of the "Overriding Method" can be same or the child
                            of the return type of the "Overridden Method"
                            From child return type to parent type you must have "IS-A" Relationship
                          9)Between the Wrapper Classes, Java did not create "Parent-Child Relationship", therefore
                            between the Wrapper Classes there is no "IS-A" relationship. If there is no "IS-A" Relationship
                            you cannot change the return types in "Method Overriding"
                          10)When you do "Method Overriding", if the return type of the "Overridden Method" is "primitive"
                            you cannot change it in "Method Overriding" because "primitive" data types are not classes
                            if they are not classes you cannot have "IS-A" relationship.

                            Note: If a method is final, it means its body cannot be updated.

                          11)Body of a "final method" cannot be updated, because in Overriding we change the method
                            body, but final methods do not allow us to change the body

                          12)"private" methods cannot be overridden, because to override a method we have to access
                            to it. "private" methods are not accessible from other classes

                          13)"static" methods cannot be overridden because "static" things are common for
                            all child classes, if any child class updates the static method body other child classes
                            will be effected as well, therefore Java does not let you override a static method.
                       */

  25-)- “static” keyword nedir?
      -Classa baglanmıs class elemanlarıdır: Variable, methodlar
      -“static” class elemanlar her objenin ortak elemanıdır.
      -static” class elemanında yapılan her degisiklik bütün objeleri etkiler, bütün objelerde görülür
      - static” class elemana class üzerinden ulasılır, objeler statiklere ulasmada kullanılmaz, kullanırsak hata vermez ama tavsiye edilemez.
      -”static”ler override edilemezler.

     1)"static" class members (variables and methods) are common for all objects created from the class
      2)When you do any update on "static" class members, all objects will see the updates on it
      3)If you want every object informed about every update on a class member make it static.

      -Variable'lar static ise class'a baglanır, stadik degilse objeye baglanır.
      -Static de yapılan her degisiklik objeler tarafından görülür ama "object"de yapılan degisiklik sadece objeyi etkiler.
      - STATİC VARİABLE'LARA OBJELERİ KULLANARAK ULASMAK MUMKUN AMA TAVSİYE EDİLMEZ
      - STATİC VARİABLE'LARA CLASS ISMI KULLANILARAK ULASILMALIDIR.

    */

     //How to create "static" variable
     //To make a variable "static", put "static" keyword between "access modifier" and "data type"
     public static int staticCounter  = 0;

  26-)   Encapsulation => package day23encapsulationabstraction; icinde.

                Encapsulation is "data hiding"
                To hide a data we make the access modifier "private"
                After "hiding data", you may need to "read" or "update" the data.
                To "read" or "update" the data we will create some methods.
                To "read" "encapsulated data" you should create "get()" methods, we name it "getters"

                To "update" "encapsulated data" you should create "set()" methods, we name it "setters"

                "get()" and "set()" methods are called "Java Beans"

                If a class is "immutable", it is impossible to change the value of the existing variable.
                If you want to make a class "immutable" do not create any "setter" method

                                ----------
               Encapsulation is "data hiding"=> Yani "data gizlemek" demektir.
              *Data'yı nicin gizlersi?
               -Data'yı dıs etkenlerden korumak icin.

              *Data'yı nasıl gizlersin?
              -Access modifier'ını "privide" yaparak gizlerim.

              *Data'yı gizledikten sonra baska classlarda okumak istersen ne yaparsın?
              - "get methodlar"(getter) olusturarak gizledigimiz dataları okunur hale getirebiliriz.

              *Data'yı gizledikten sonra baska classlarda degistirmek istersen ne yaparsın?
               - "set methodlar"(setter) olusturarak gizledigimiz dataları degistirebliriz.

               * generate => gettir or setter


       GET: "gettir" kullandıgımızda Okuma yaptıgımız icin access modifier public olur.
           -Variable'ın "data type"ı ile get methodun return taype'ı da aynı olmalı.
             Yani variable String ise getir ile aldıgımız methodun da data type'ı string olur.
           -get methodları isimlendirirken "get+ <variable name>", ancak variable'ın data type'ı "boolean" ise "is+<variable name>"
            ör:  private String stdId = "TH123"; ==>  public String getStdId() {return stdId; }
                private boolean successful = false; =>public boolean isSuccessful() {return successful; }

           set:-set methodu datayı degisiklik yapmada kullanırız
           -access modfier'ı "public" olur: baska sınıftan ulasmam icin.
           -set methodunun return type'ları "void" olur.
           -set methodların ismi hep set ile baslar, "set+ <variable name>". ör:
                public void setStdGpa(double gpa){ this.stdGpa = gpa; }
                public void setSuccessful(boolean successful) { this.successful = successful; }
           -set method parametre ile calısır.Parametre data tipinde ve isminde olur, isim aynı olmak zorunda dagil ama genel kullanım odur.
            private double stdGpa = 3.8; => "double" oldugu icin set methodunun data type da "double" olur =>   public void setStdGpa(double gpa){ this.stdGpa = gpa; }

           -Baska bi class'dan obje olusturunca :Ve objeyi kullanarak variable'ları cagırdıgımızda class icindekiler okur
              Ama olusturdugumuz obje ile variable'larda degisiklik yapmak istedigimizde asıl class'dakiler ile degil
              olusturdugumuz obje üzerinde degisiklik yapar, asıl clastaki variablelar degismez.
              Degisim classda degil objede olur.


   27-)             "Abstraction"

        1)Sometimes no child uses the implementation from the parent class, therefore
          the body part of the method in parent class is being unusable.
          If something is unusable we do not want to type it.
          If you do not type the body of a method, you will have "method without body"(Like angels),
          it is called "Abstract Method"

       2)"Concrete Methods"(Methods with body) focus on 2 things; i)What to do ii)How to do
         "Abstract Methods" focus on just "What to do"

       3)If you make a method "abstract", it will be mandatory to override for all child classes


       4)"Abstract Methods" can be created just in "Abstract Classes"
          To make a Class abstract put "abstract" keyword between "access modifier" and "class" keyword

       5)When you remove "method body" you have to use "abstract" keyword between the "access modifier" and the "return type" of the method

       6)It is impossible to create "object" from an "abstract class" but it does not mean "abstract classes" do not have "constructors"
          They have "constructors" but "constructors" are not used to create objects

       7)"Abstract Classes" can have "concrete methods" as well.

       8)"Concrete Methods" may or may not be overridden by Child Classes

       9)"Abstract Methods" cannot be put into a non-abstract class

                  ---------
       -Parent class'a koydugumuz methodun body'i hicbir child tarafından kullanılmayacaksa yazmamız gereksizdir.
       -Method var ama body'si yoksa bunlara "abstract method" denir.
       *Abstac Method yapmak icin: 1- Methodun body'sini silmeliyia
                                   2- access modifiar'dan sonra "abstract" keyword'unu yamalıyız.
                                   3- "aabstact method"'lar "abstract class"'lar icinde olmalıdır.

       *abstract classlarda "Concrete Methods" ve  "Abstract Methods" olabilir.
         "Concrete Methods" body'i olan classlara denir.
       *Parent'a abstract yapınca "abstract methodlar" var ise:
       i) child clss'ı abstract yapılmalı:ör:public abstract class Mammal extends Animal{
        VEYA
       ii) parent class'daki tüm "abstract method"ları override etmelisiniz.ör:sag tıkla=> generate =>Override
         @Override
        public void eat() {
          System.out.println("Cats eat...");
        }
            /*
          Normally child class must override all "abstract methods" from the parent class.
            Even Mammal Class did not override anything from the Animal Class, no complain.

            Because "Overriding abstract methods from parent" is mandatory just for "Concrete Classes"

            "Overriding abstract methods from parent" is NOT mandatory for abstract classes


            If you want you can ovverride abstract methods from parent Animal to Mammal, it is optional.

             */

        *Bir method parent classta abstrac method  ise tüm child classlar onu mutlaka kullanmak zorunda.(override yaparak kullanır)
         Bu nedenle her hangi bir fonksiyonu "chid class" icin mecburu yapmak isterseniz o methodu "abstract" yapmalıyız.


   28-)       "interface"

          * Atomic olsun diye "parent" classı parcalayıp farklı fonksiyomlar icin farklı parent classlar olusturup ,
           child classı da onlara baglamak istesek birden fazla parent olacagından dolayı java kabul etmez.
           Cünkü java "multible ınheritance"ı desteklemez. Fakat java "interface" diye yeni bir yapı olusturdu bu yapıyı da
           "multible inheritance"a müsade etti.(Cünkü methodun body'i bos interface'lerde.)

          * Bir classı bir interface'in child'ı yapmak icin "implements" keywordu kullanılmalı
            ör: public class Honda implements Ac, Brake, Engine {

               "" methodlar"

          *interface olunca methodlara body koyulamaz, kabul etmez.
          ör:public void ecoEngine();

          *interface'lerde abstract method olustururken "abstract" keyword kullanmaya gerek yoktur.
          ör:  public abstract void ecoEngine(); => yerine  => public void ecoEngine();

          *interface'lerdeki tüm methodlar java tarafından otomatik olarak "public" kabul edilir, bu nedenle o methodlar icin
           access modifier olarak "public" yazmaya gerek yoktur.(yazsakta sıkıntı olmaz)
            ör: void ecoEngine();
             public abstract void ecoEngine(); ile void ecoEngine(); aynı anlama gelir.
          *interface'lerdeki tüm metodlar "abstract" oldugu icin interface'lere "fully abstraction" (tam abstract) denir.
           "abstract class"larda "abstract method" ve "concrete method" bir arada kullanıldıgı icin "abstract class"lara
           "fully abstraction" denmez, yani yarım abstacttır.

           * To create "concrete method" in an interface you have 2 potions
              i) Use "default" keyword     ii) Use "static" keyword
           - interface'lerde normalde  "concrete method(body'i olan)" koymamıs java ama developerların istegi üzerine koymus
             ama "defoult" keywordu kullanmak sartıyla, kullanmassak hata verir. Bu istisnai bir durumdur.
             ör:  public default int calculate(){
                   return 1200;
                  }
            -"static" keyword kullanarakta interfacelerin icinde body'si olan methodlar üretilebilir, bu da istisnai bir kullanımdır.
            ör: public static String update(String str){
                return str + "!";
                }

             *"abstract methodlar" sadece ne yapılacagını söyler(what to do)
              "concrete method"lar ne yapılacagını (what to do) ile birlikte nasıl(How to do) da söyler.

              -interface'ler bir yapılacak isler listesidir.(To do list)
                    "method"
             *"multible parent interface" kullandıgınızda aynı method isii ile birden fazla method olusturulunca
               rutern type'ları aynı olunca , java sıkıntı yapmaz.
               ör: public void run(); farklı parentlerde aynı method kullanılınca child da sıkıntı olmaz.

            *"multible parent interface" kullandıgınızda aynı method isii ile birden fazla method olusturursanız bu method'ların
             return type'ları aynı olmalıdır..Aksi takdirde hata verir.

            ör: Ama parenten birinde "public void price();" digerinde "public int price();" olunca child class bu methodu kullanmak
                isteyince sorun cıkar. Onedenle parentler de aynı isim aynı return type ile method olmalı.
             --
                    "variable"
             *iterface'lerdeki tüm variable'lar otomatik olarak(defoult) "public"tir.
             *iterface'lerdeki tüm variable'lar otomatik olarak(defoult) "final"tir.Olusturdugumuz variable'la deger ataması
             yapmazsak sikayet eder java degr ataması yapınca sikayet ortadan kalkar, "final" oldugunu burdan anlıyoruz(atanan deger degistirilemezdi finalda).
             ör: int price = 2300;
             *iterface'lerdeki tüm variable'lar otomatik olarak(defoult) "static"tir.

            note:public static final int price = 2300; seklinde de yazabiliriz ama intellj "public static final" kısmını silik yazar yani yazmasanda olur demektir.

            * multiable interface parent oldugunda aynı isimle variable olusturulabilir parent classlarda,
              java'nın aklı karısmaz cünkü variable cagırıken class ismiyle cagırdıgımız icin hangisini kullanacagını bilir java.

            *multiable interface parent oldugunda aynı isimle ve aynı data type ile VEYA aynı isim farklı data type ile variable
             olustursak parent classlarda,gene problem olmaz.

             NOT: interface'lerden object olusturulamaz. Cünkü interface'lerde constructor yoktur.
             "abstract class"larda class oldukları icin constructor vardır. Ama constructor'lar abstract class'larda object olusturamazlar.
       --------------------------------------------------------------------------

          * Child      Parent
            Class =>  Interface   => implements
            Class =>  Class       => extends
            Interface = Interface == extends
            Interface => Class    => mumkün degil
            -------------------------------


  29-)     INTERVİEW!!!! ABSTRACT CLASS İLE INTERFACE'IN FARKI NEDİR?

            1- Method
             "abstract class" hem abstract hem de concrrete method'lar icerebilir.
             "interface"ler ise sadece abstract method'lar icerir.
             Ama istersek interface'ler icinde de "defoult" ve "static" keyword'leri kullanarak concrete method lar olusturabiliriz.

           2- Variable
             "abstract class"larda normal class'lardaki gibi her türlü variable olusturulabilir.
             "ınterface"lerde ise variable'lar public ,static ve final olmak zorundadır.

           3- Inheritance
             "abstract class"lar class oldukları icin multible inheritance'a müsade etmezler.
             "interface" ler ise multible inheritance'i desteklerler.

           4- Object creation
             "abstract class"larda constructor vardır ama object olusturmada kullanılmazlar.
             "interface" lerde ise constructor olmadıgından object olusturulamaz.


 INTERVİEW!!!!    Soru: Object Oriented Programing Language prensibleri nelerdir?
                  i- inheritance  ii- polymorphism  iii- encapsulation iv- abstraction
                            ***************************************************



           1)An interface cannot have "concrete method"
           2)All methods in an interface are "public" and "abstract" as default
             Because of that; even you don't declare the methods "public" and "abstract", they will be "public" and "abstract"
             "public abstract void digital();" and "void digital();" are same
           3)If "parent interfaces" have methods with the same name, overriding just one of them will be enough.
           4)"parent interfaces" cannot have methods with the same name and the different return types.
              If you do that, Java will give you compile time error
           5)Variables in an interface are "public", "static", and "final"
             "public static final int price = 2300;" and "int price = 2300;"
           6)Variables in interfaces are "static" default, therefore no need to create object to access
             variables in interfaces.
           7)Whenever you need to call any variable use "Interface Name" to call

           8) "Class" parent of another "Class" ==> extends
           "Interface" parent of another "Interface" ==> extends

           "Interface" parent of "Class" ==> implements
           "Class" parent of "Interface" ==> impossible. ==> An "Interface" can have "just" Interface as parent
              ---------------

   30-)   "final"
                "final" keyword is very important in Java
                    1)"final" keyword can be used for variables
                      public final int age = 12;
                      If you make a variable "final" you cannot change its value
                      "final variables" must be initialized.

                    2)"final" keyword can be used for methods
                      "final method" body cannot be updated

                    3)"final" keyword can be used for classes
                      "final classes" cannot have child classes

                Note: "abstract classes" have something to do for child classes, if there is no child class, having "to do list" is not sensible.
                      "final classes" cannot have child classes, therefore Java does not allow to make an abstract class final.

                Note:  "final method" body will be under protection by Java, because it should not be updated.
               But abstract methods don't have body, Java will look for the body to protect when it could not find it will complain


    31-)          "final" , "finally" , "finalize" nedir acıklayınız:

                  "final": Bir keyword'dür. verable,method , class icin kullanılır....
                  "finally": -Bir "code block"dur.(süslü parantez icine yazıyoruz)
                            -"try-catch" veya sdece "try" ile de kullanılabilir.
                            - "finaly" code block icine yazılan code'lar her halukarda calıstırılır(ister exception olsun ister olmasın, her zaman calısır)
                             Mesela Database ile connection'ı kesmek herhalukarda yapılması gereken bir fiildir.Bunu "finaly" ile yaparız.
                            -"finaly" code blockunun en sonunda kullanılır.
                 "finalize" : Bir methoddur. Bu method java tarafından datalar imha edilmeden cagrılır, bu method dataları imha edilecek
                             duruma getirir ve daha sonra "Garbage Collector" bu data'ları imha eder.
                             -"finalize" methodunu Java Developer'lar da cagırabilir ama Java kendi bildigini yapar.



    32-)    "Exception"

             1)"Exception" means un-expected issues in code execution
               2)There are two ways to work with Exceptions
                   i)Using try-catch block: Handling Exception: exception olsa bile calısmayı devam ettirir.
                   ii)Throw Exception and block the application: "throw" ise calısmayı durdurur.
               3) If you do not handle the Exception, Java stops execution and the application is blocked.
               4) "try" can be used with a "single" or "more" catch blocks: "try" bir kere, catch block'u ise bir ve daha fazla kullanabiliriz.
               5) "try" "cannot" be used "alone": "try" tek basına kullanılamaz.
               6)(e.getMessage());//Gives technical message about the Exception
                 ör: System.out.println(e.getMessage());//Gives technical message about the Exception
               7) System.out.println("A problem occurred in array indexes"); seklinde catch bloc icine yazdıgım kod yazanın
                    kendisi icin yazdıgı, teknik olmayan mesajdır.
               8)   e.printStackTrace();//Gives detailed technical message about the Exception.Detaylı
                    "log(application'nın adım adım ne yaptıgını gösterir)" icin. Bunu kullanırken sout icine
                    yazmaya gerek yok,cünkü kendi icinde print var. Genelde developurlar bunu kullanırlar.
               9) System.err.println("A problem occurred in array indexes"); Bu ise kendi mesajımı konsolda renkli yazdırı,
                   renkli gösterir. Hata olan yeri daha rahat görmek icin kullanılır.
               10) try icindeki kod düzgün calısırsa "catch" kısmı calısmaz.

               11- Aralarında "parent-child" relationship olan Exception Class'ları multible catch'lerle kullanmak isterseniz
                  "child" olan önce kullanımalıdır, aksi takdirde hata verir.
               12-  Aralarında "parent-child" relationship olan Exception Class'ları multible catch'lerle kullanmak isterseniz
                    sıralamanın bi önemi yoktur.


                  ---
                  Java'da bir program calısırken, farklı sorunlar ile karsılasılabilir, beklenmedik bu sorunlara "exception"denir.
                  Bu sorunların sebebi: code da hata olabilir, kullanıcı yanlıs degerler girebilir, internet baglantsı kesilmesi...

                *"if-else" We do not recommend that way.
                 i)It is not mandatory for developers to know all math rules.
                 ii)In Math, there may be very problematic rules, it is so difficult to cover all in if statement

                         *************
                         Exception 2'ye ayrılır.
                         i-RunTime Exception(diger ismi Unchecked exception)
                         ii-CompileTime Exception(diger ismi Checked exception)

                          i-RunTime Exception
               1-"AritmeticExeption" :matematik ile ilgili yapılan yanlıslıkları kapsar. Bunu if-else ile de cözebiliriz fakat
                                      matematik kurallarını bilmemize gerek yok bu nedenle exceptionlarda kullanımı tavsiye edilmez
                                      onun yerine try-chatch kullanırız.Handle Exception by using try-catch block
               2-ArrayIndexOutOfBoundsException : Bir arrayde length'inin bir eksigini index olarak alabiliriz.
                                                  Ama length-1 den fazla bir rakam girersek hata alırız. Yani arrayin uzunlugunu asarsa istedigimiz hata verir.

               3-NullPointerException: If  you use "length()" method with "null" you will get NullPointerException
                 int r3 = getNumOfChars(null);
                 System.out.println(r3);
                 Eger lenght() methodunda "null" kullanırsanız "NullPointerException" alırsınız.

              4-NumberFormatException: If you use "valueOf()" method with a String has non-digit character in it,
                you will have NumberFormatException. Yani String icinde rakamlar haricinde harfler gibi farklı karakter varsa bunu
                "valueOf()" kullanara integer'a cevirmek istedigimizde  exception'u verir.

              5-StringIndexOutOfBoundsException: If you use non-existing index for a String, you will get StringIndexOutOfBoundsException
                        Stringin sınırlarının yani indexinin  dısına cıkınca, stringde var olmayan idx kullanıldıgında bu exception verir.
                 Yani: char r1 = getCharFromString("Java", 9);
                       System.out.println(r1); //String2imin indexi 3 ama ben 9 girdigim icin bu exceptionu alırım.

            6-IllegalArgumentException: uygun olmayan deger hatası demek. örnegin yas icin olan bir methodda eksi bir deger girerse kullanıcı
               aplicationa uygun olmayan bir deger girmis olur. Bunu da "throw"  yani exception atarak engelleyebiliriz.
               Yani burda biz bilerek yanlıs bir deger girildiginde exception atarak uygulamanın durmasını saglamıs oluyoruz.
               -exception'ı biz üretirsek methodumuzda ,istersek try-catch ile method dısında cözüm üretebiliriz.
           -Method icinde exception nicin üretilir? -APLİCATİONUN MİMARLARININ OLUSTURDUGU KURALLARI KOYMAK İCİN
                                                    -GÜNLÜK HAYATTA YASAK AMA JAVA İCİN YASAK OLMAYAN SEYLER İCİNDE EXCEPTİON ATILIR.(18 YAS ALTI CALISMA IZNI OLMAMASI GİBİ)

                    ii-"Compile Time Exception"(Checked Exception)
             1-"FileNotFoundException" : "FileNotFoundException" is the child of "IOException"
             2- "IOException" : IOException is parent exception. "IOException" is related with all possible "input-output" issues

             *********************************************************************************
                   1)If you want to execute a code for every scenario, use "finally" block after "try" body
                   2)"try" can be used like i) try + single catch  ii)try + multiple catch  ii)try + single catch + finally
                                            iv)try + multiple catch + finally   v)try + finally
                                            Note: "try" cannot be used alone
                   3)"ArithmeticException", "NullPointerException", "ArrayIndexOutOfBoundsException", "NumberFormatException",
                     "StringIndexOutOfBoundsException", "IllegalArgumentException"  are displayed on the console after I click on "Run" button
                     therefore those are called "RunTime Exception"
                   4)There is "Compile Time Exception", they will be displayed before clicking on the "Run" button.
                     Therefore, they are called "Compile Time Exception"
   *********************************************************************************

                    "final" , "finally" , "finalize" nedir acıklayınız:

                   "final": Bir keyword'dür. verable,method , class icin kullanılır....
                   "finally": -Bir "code block"dur.(süslü parantez icine yazıyoruz)
                             -"try-catch" veya sdece "try" ile de kullanılabilir.
                             - "finaly" code block icine yazılan code'lar her halukarda calıstırılır(ister exception olsun ister olmasın, her zaman calısır)
                              Mesela Database ile connection'ı kesmek herhalukarda yapılması gereken bir fiildir.Bunu "finaly" ile yaparız.
                             -"finaly" code blockunun en sonunda kullanılır.
                  "finalize" : Bir methoddur. Bu method java tarafından datalar imha edilmeden cagrılır, bu method dataları imha edilecek
                              duruma getirir ve daha sonra "Garbage Collector" bu data'ları imha eder.
                              -"finalize" methodunu Java Developer'lar da cagırabilir ama Java kendi bildigini yapar.

    NOT:  package day26exceptions;  class E03readTheText icinmde reed the text var.ve bu classta kod yazarken ortaya cıkan exception var.


       -When you use parent and child exception classes together in a try-catch,
          child classes must come first otherwise Java gives error.

       -When you encounter a "Compile Time Exception", you have 2 options
            i)Using "throws" in method signature line
                *Java will throw exception and stop the execution
            ii)Using "try-catch" block
                *Java will execute whatever you typed inside the catch body and does not stop the execution

    33-)        What is the difference between "throw" and "throws" keywords?
                     *** i)"throw" keyword is used to throw any Exception in anywhere inside the method body
                           "throws" keyword is used in the method signature line
                     ii)By using "throws" keyword you can declare multiple exceptions
                        After using "throw" keyword you can declare just one exception
                     iii)After using "throw" keyword, you have to create an Exception object
                         After using "throws" keyword, you will tell just the name Exception class

    34-)           EXCEPTION OLUSTURMA:
                    SORU: Costum Exception nedir ve nasıl üretilir?
                    -Java kendi kurallarını exception olusturarak, developerların bu java kurallarına uymasını saglamıstır.
                    -Bizde application üretirken kendi exceptionumuzu olusturarak diger developerların bizim kurallara uymasını saglamıs olusruz.
                     Bizim ürettigimiz exceptionlar'a "Costum Exception" denir.
                    -Custom exceptionlar da  "Run time Exception" ve"Compile Time Exception" olabilir.
                    -Custom "RuntimeException" üretmek icin "extends RuntimeException" seklinde yazarız.
                    -Custom "CompaileTimeException"  üretmek icin "extends Exception" yazılır.


              A-) "Compile Time Exception"(Checked Exception) OLUSTURMA (=>package day27exceptionscollections; de IllegalGradeException ve IllegalNameException classlarında)
                - To make a class "Exception Class" make it child of the "Exception Class" by using "extends" keyword
                 -If you use "extends Exception" it will be "Compile Time Exception"(Checked Exception)
             - Bütün exeption'ların sonunda "exception" kelimesi vardır o nedenle kendimizin ürettigi exception class'ın
               isminin sonundada "exception"kelimesi kullanmalıyız. ör: IllegalGradeException
               Ve "extends" etmeliyiz "Exception"sın parent clasına.
             -constroctor olustur ve obje olustururken excepsınımız ile ilgili mesajıda kullanmak icin icine "String message" koydum.
              Bununda parent classına gidip alır : "super(message);" bunu parentdaki message iceren constructor'ı kullan.

             B-) RuntimeException OLUSTURMA:
               When you "extend" to "RuntimeException Class",your "Custom Exception" will be "RuntimeException"
               public class IllegalNameException extends RuntimeException{
               }


   35-)   "COLLECTION"
           Collections are for storing multiple data in the same data type.
            Collections are flexible in length.
            Collections have many useful methods.

              There are 3 main Collections: i)List ==> a)ArrayList:Successful in "search operations" but not good at "adding" and "removing"
                                                       b)LinkedList:Successful in "adding" and "removing" not good at "search operations"
                                            ii)Queue ==> a)PriorityQueue  b)Deque
                                            iii)Set ==> a)HashSet  b)LinkedHashSet  c)TreeSet
                  ******************************
             1-List:Coklu ve tekrarlı data depolamak istedigimizde ihtiyac duyarız
                    Bir okuldaki ögrenci isimleri
             2-Set: Coklu ama tekrarsız data depolamak istedigimizde ihtiyac duyerız.
                   Bir okuldaki ögrenci id'lerini depolamak icin
             3-Queue:FIFO veya LIFE gerektiginde kullanırız.
                  Bir bankada islem yapma sırasını bekleyen müsterileri sıralamak icin

                       ----
                        A- "LIST"
                       "LinkedList"

              -ArrayList'ler index kullanır ama index kullanmak ,eleman ekleme ve eleman silme islemlerinde
                   bize zaman kaybettirir. Cünkü bircok elemanın re-index edilmesi gerekir.
                         "LinkedList"
               1 -)LinkedList:Elemanlar 2 bölümden olusur; data ve pointer. "Linked"  demek birbirine baglanmıs demek.
                          Element yerine LinkedList de "node" olarak adlandırılır.
                          Her node'u bir pointer(ok ile) ile diger node'a baglar.En sondaki pointer'a "tail"(kuyruk) denir.
                          En bastaki node'u gösteren sadece bir ok(pointer) var. Ona da "head" denir.
                2-)LinkedList’ler eleman silme ve eklemede basarılıdırlar.Bu nedenle elemen silme ve eklemede LinkedList ler kullanılır.
                Örnegin bir müzenin günlük ziyaretcileri icin kullanılabilir, sil-ekle islemi tekrar tekrar olur. Bu islemi hızlı olması gerekir.
                3 -)LinkedList’ler eleman arama islemlerinde basarısızdırlar.
                4-) 2. ve 3. maddelerden dolayı eleman silme ve ekleme islemlerinin cok yapılacagı durumlarda LinkedList kullanılmalıdır.
                5-)ArrayList'ler index kullanır LinkedList’ler index kullanmaz.
                6-) index kullanmak eleman bulma islemlerinde cok basarılıdır. Bu yüzden eleman bulma islemlerini yapacagımız islemlerde ArrayList kullanmalıyız.
                7-) LinkedList’ler eleman silme ve eklemede basarılı oldukları icin  ekleme ve silme ile ilgili fazla method icerir.
                    addFirst(), addLast(), removeFirst(), removeLast(), removeFirstOccurrence()......


              -ArrayList eleman bulma (search) islemlerinde cok basarılıdır, cünkü index kullanarak bulur.
               LinkedList ise  eleman (elemenın adressini) bulma(search) bulmada basarısızdır, cünkü index kullanmadıgı icin bastan baslar
                tek tek elementleri kontrol eder taki istedigi elementi bulana kadar, buda zana kaybı demek, hızını azaltır.
              ör: "Süzlük" ile ilgili bir applicationda ArrayList kullanmak daha mantıklı.kelimeler bir kere koyulur ve search yapılır daha cok.
                  Sehir isimleri, bölgeler gibi aplicationlarda ArrayList kullanmak daha iyi olur, sehir isimleri kolay kolay degismez ve
                  sehirler ile ilgili bircok konuda arama islemi yapılabilir.

         LinkedList Methodları:

               LinkedList<String> visitors = new LinkedList<>();
               visitors.add("Tom");
               visitors.add("Jane");
               visitors.add("Mary");
               visitors.add("Carl");
               visitors.add("Ali");

               System.out.println(visitors);// [Tom, Jane, Mary, Carl, Ali]

         1) add()
         2) addLast()
         3) addFirst()
         4) addAll()
         5) remove() :method removes the "first occurrence" of the object
         6) removeFirst()
         7) removeFirstOccurrence()
         8) removeLast()
         9) pop() method ilk elementi siler ve bize sildigimiz elementi verir.Bu method removeFirst() methodu ile aynı isi yapar.
                Eger list bos ise(emty) NoSuchElementException atar.
         10) peek() methodu ilk elemanı verir ve elemanı silmez listten. Eger list bos(emty) ise "null" döndürür.
         11) poll() methodu işlk elementi verir ve listten ilk elemanı siler. pop() methodundan farkı ise; list bos ise exception
                 vermez "null" verir.

         12) element() methodu: first elementi verir ve list'ten silmez. Eger list bos ise "NoSuchElementException" exception atar.
                                     Retrieves, but does not remove, the head (first element) of this list.
                                     Throws: NoSuchElementException – if this list is empty

         ****************************************************************************
                    B-  "SET"

            1)Sets are for storing multiple non-primitive data in the same data type
            2)Sets are for storing unique data like email addresses, SSN, Phone Numbers in a Country, ...
            3)There are 3 different Sets: i)HashSet: Uses "Hashing Technique".
                                                     It does not put the elements in any order.
                                                     HashSet accepts just a single "null" as element
                                          ii)LinkedHashSet: Puts the elements in "Insertion Order"
                                          iii)TreeSet: Puts the elements in "Natural Order"(Ascending Order in numbers, Alphabetical Order in Strings)
                                              TreeSet is so slow in adding elements

                  ***************************
                    "HashSet"
               HashSet<String> emails = new HashSet<>();
      Hash bir tekniktir, birbirine benzemeyen code'lar üretür bu code'lar data'yı unique yapar.
     -HasSet'lere coklu ama tekrarsız data depolamak istedigimizde ihtiyac duyarız.(ögrenci numaraları gibi)
     -Set'lere var olan elemanı eklersek hata vermez, son ekleneni var olan data'nın üstüne yazar(yani overwrite yapar).
     -"null" element kabul eder.
     -HashSet'ler eklenen elemanların sıralaması ile ugrasmaz.Sıralama ile alakalı zaman harcamaz buyüzden cok hızlı calısır.
     -HashSet'ler index kullanmaz, cünkü her calısmada elementin yeri farklı olabilir, rastgele sıralar.
                 *** HashSet'leri:1) Tekrarsız elemanlar gerektiginde
                                  2) Sıralama önemli olmadıgında
                                  3)Hız cok önemli ise, kullanılır.

                          ***

                    "LinkedHashSet"
             LinkedHashSet<Integer> ssn = new LinkedHashSet<>();
    -LinkedHashSet'ler elemanları ekleme sırasına(Insertion Order) göre yerlestirirler.
    -LinkedHashSet elemanları sıraşlamada zaman harcadıgı icin HashSet'lere göre yavas caalısırlar

                     ***
                  "TreeSet"
            TreeSet<Integer> nums1 = new TreeSet<>();
     -TreeSet tekrarsız elemanları "alfabetik" veya "kücükten büyüge"(natural Order) dizer.
     -TreeSet coooook yavas calısır(elemanları natural Order a göre sıraya koydugu icin).
     -TreeSet does not accept "null" as element
               **************

    !!!! INTERWİEV Question: If you need to store "unique elements" in "natural order", which collection do yo use?
                  Answer: TreeSet
        Question: As you know, TreeSet is so slow in adding elements, how can you improve your code?
                  i)Create a HashSet
                  ii)Add elements into the HashSet
                  iii)Convert HashSet to TreeSet
      note: Tekrarsız elemanları natural order da depolamak icin TreeSet kullanmak mantıklıdır ama TreeSet ler cook yavas calıstıgı
            icin biz, elemanları önce HashSet ile depolarız sonra HashSet'i TreeSet'e cevirerek
            TreeSet'in yavas olma problemini atmıs oluruz.

        //1.Way: Slower
        Long starting = LocalTime.now().toNanoOfDay();
        TreeSet<Integer> nums1 = new TreeSet<>();
        nums1.add(23);
        nums1.add(5);
        nums1.add(17);
        nums1.add(67);
        nums1.add(41);
        nums1.add(-5);
        //nums1.add(null);//TreeSet does not accept "null" as element
        System.out.println(nums1);//[ -5, 5, 17, 23, 41, 67]

        Long middle = LocalTime.now().toNanoOfDay();
        System.out.println(middle - starting);

        //2.Way: Faster
        HashSet<Integer> nums2 = new HashSet<>();
        nums2.add(5);
        nums2.add(17);
        nums2.add(67);
        nums2.add(41);
        nums2.add(-5);

        Set<Integer> perfectNums = new TreeSet<>(nums2); //HashSet'i TreeSet'e cevirmek icin bu kodu yazdık.
        System.out.println(perfectNums);//[ -5, 5, 17, 23, 41, 67]

        Long ending = LocalTime.now().toNanoOfDay();

        System.out.println("1.Way: " + (middle-starting)); //5998100
        System.out.println("2.Way: " + (ending-middle));   //0 bir nanosecenttan az oldugu icin 0 verdi cok hızlı.
    }
 *************************************************************************************
                          C- "QUEUE"
                 "Queue"
           Queue<String> wareHouse = new LinkedList<>();
        1)Queue's are for storing multiple non-primitive data in the same data type
        2)Queue's are used for FIFO(First In First Out)

       - Queue interface'dır ve bu nedenle object olusturamayız.Queue olusturulurken ya LinkedList veya PriorityQueue ın constructorını kullanabiliriz.
       -Ilk giren eleman ilk kullanmamız FIFO(First In First Out) gerektiginde Queue en iyi secimdir.
       -Queue lar elemanları verilen sıraya(ınsertion order) göre dizer.
       -add(), peek(), poll(), element(), , remove() gibi ilk elemanı ilgilendiren bir cok method vardır.
       -offer() methodu kapasite kontrolu yapıldıktan sonra eleman ekleme durumlarında kullanılır.Eleman eklenirse true verir ,eklenemedi ise false verir.

                      "Deque"
             Deque<String> furnitureTruck = new LinkedList<>();
       -Deque constructor olarak "LinkedList" i kullanır, cünkü parent'ı olarak normal class olarak LinkedList var, digerleri interfase.
       - Deque's are for storing multiple non-primitive data in the same data type
       "Deque" means "Double Ended Queue", it works successfully in FIFO and LIFO operations
       -Yani iki uclu queue demektir.FIFO ve LIFO gerektiginde beraber kullanılır.
       -removeLastOccurrence(), removeLast(), addFirst(), addLast() gibi ilk ve sona eleman ekleme-silme gibi bircok methoda sahiptir

                     "PriorityQueue"
               PriorityQueue<String> myQueue = new PriorityQueue<>();
        -Java kendine göre bir kural belirler ve ona göre elementleri sıraya koyar.Yani yazdıgımız sıraya göre veya alfabetik
         sıraya göre bir sıra yapmıyor, ama java bir sıra yapıyor fakat kendine göre bir sıra yapıp elemanları yerlestiriyor.
        -Biz istersek sıralamayı belirleyebiliriz.

